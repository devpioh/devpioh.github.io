---
title: "unitask"
date: 2024-05-28
last_modified_at: 2025-05-09

toc: true
toc_sticky: true

categories:
    - unity
tag:
    - [unity, unitask, async/await]
---

## 개요
CySharp 에서 개발된 유니티 전용 비동기 라이브러리

c# 비동기 처리 키워드인 async/await를 이용하여 비동기 흐름을 제어하므로 기존 Unity의 Coroutine보다 직관성이 있다.

비동기 스레드 작업에 맞춰진 c#의 Task보다 가볍고, 내부 객체 Pool을 이용하여 초기 메모리 할당외에는 없다.(new로 인한 GC발생 최소화.)

가장 큰 이점은 Unity Api와 완벽히 호환되고 여러 편의 헬퍼 기능으로 작업이 편리하다. 기존에 사용되는 Coroutine 구문을 별도의 마이그레이션 작업 없이 사용이 가능.

c# async / await 패턴을 사용하므로 c# 네이티브 Task와도 호환이 가능하다.

이러한 이점으로 인해 많은 프로젝트와 유니티 서드 파티 패키지에서도 유니태스크를 채택/지원이 늘어나고 있다.

## 동기(synchronous) / 비동기(asynchronous)
유니태스크에 대해 알아보기전에 동기와 비동기에 대해 간단히 요약 정리.

#### 동기(synchronous)
* 흐름이 순차적으로 진행.
* 함수(메서드) 호출하면 끝날때까지 호출 한 쪽이 대기.
* 호출 -> 처리 -> 다음 코드 ... 로 흐름 예측이 쉽고 직관적.
* 예외처리 및 디버깅이 간단.
* 호출 시 호출 한 쪽이 대기(블로킹 / blocking) 으로 인해 처리 지연.

#### 비동기(asynchronous)
* 처리 요청 후 해당 처리가 끝날 때까지 대기 하지 않음.
* 작업이 완료되면 콜백(CallBack), 이벤트, Promise/Task등을 통해 결과를 받음.
* 호출 즉시 제어권 반환 -> 다른 작업의 수행 가능.
* 호출시 대기를 하지 않고 다른작업이 가능.(논블로킹 / non-bloking)

## PlayerLoop
- 유니티 엔진이 한 프레임을 처리하기 위해 실행되는 일련의 과정.
- 우리가 MonoBehaviour에서 친숙하게 사용되는 Awake, Update, Destory 등을 비롯한 각종 콜백들이 유니티의 PlayerLoop의 순서로 언제 호출될지 결정.
- 유니티 2018.1에서 도입된 커스텀 가능한 PlayerLoop는 좀 더 세부적으로 PlayerLoop의 과정을 나눌 수 있게 됨.
- 내부적으로 PlayerLoopSystem 구조체 배열로 관리되고 있으며, PlayerLoop.GetDefaultPlayerLoop()를 이용하여 단계를 확인 가능.
- UniTask는 이 커스텀 가능한 PlayerLoop를 이용해 구현되었으며, 이로 인해 UniTask에서 Unity Api 호출이 안전한 이유이다.
  * 단, UniTask.SwitchToThreadPool()은 유니티 메인스레드가 아닌 스레드에서 동작되므로 주의 필요. 
  * 자세한 [UniTask PlayerLoop](https://gist.github.com/neuecc/bc3a1cfd4d74501ad057e49efcd7bdae) 확인 가능

## Coroutine vs UniTask
## Unity Awaitable vs UniTask


## 출처 및 같이 보기
 - [UniTask](https://github.com/Cysharp/UniTask#getting-started)
 - [UniTask PlayerLoop](https://gist.github.com/neuecc/bc3a1cfd4d74501ad057e49efcd7bdae)