---
title: "Graphic Pipeline"
date: 2022-07-14
last_modified_at: 2025-10-05

toc: true
toc_sticky: true

categories:
    - graphics
tags:
    - [graphics, graphic pipeline]
---

## 개요

작년 겨울에 그래픽스 스터디를 진행하면서 정리한 그림과 간단한 설명을 기록해보려고 한다.
(필자가 유니티 개발자라 유니티 용어가 섞여 정리될 수 있는데 만약 잘못된 내용이 있다면 알려주시면 감사하겠습니다.)

## 그래픽 파이프라인이란?

그래픽 혹은 렌더링 파이프라인을 간단하게 한 문장으로 말한다면 아래와 같다.

***1 프레임이 화면에 그려지기까지의 과정***

화면에 3D 물체를 그린다는 것은 CPU가 GPU에게 그려줘!(Draw Call)라는 명령을 보내는것이다.

![DrawCall](/assets/images/GraphicPipeline/rendering-pipeline-005.jpeg)

하지만 단순히 "그려줘!"라고 명령하는 것만으로는 충분하지 않다.

CPU와 GPU가 서로 다른 방식으로 데이터를 처리하기 때문에, 정확한 렌더링을 위해서는 복잡한 과정을 거쳐야 한다.

GPU가 올바르게 렌더링하려면, 3D 오브젝트가 어떤 방식으로 표현되어야 하는지에 대한 세부 데이터가 필요하다.

그리고 다들 잘 알다시피 CPU와 GPU는 처리 속도가 다르므로 이걸 어느정도 동기화를 시켜서 순차적인 이미지를 보여줘야된다.

![Detail DrawCall](/assets/images/GraphicPipeline/rendering-pipeline-006.jpeg)

일단 이 과정을 좀 더 풀어 본다면 위의 그림과 비슷하다.
  
CPU는 GPU에게 3D 오브젝트의 그리기 정보가 담긴 RenderPass를 만든다.

RenderPass는 하나가 될 수도 있지만 여러 개 일수도 있어서 커맨드 버퍼라는 공간에 담고, 커맨드 버퍼를 커맨드 버퍼 큐에 집어 넣는다.

그리고 비로소 GPU는 해당 커맨드 버퍼 큐에서 커맨드 버퍼를 뽑아서 CPU의 그리기 명령을 처리한다.

이제부터가 본격적인 렌더링 파이프라인(CPU 그리기 명령의 처리 과정, 이미지의 초록색 영역)의 시작이다.

크게 5단계로 이루어 진다고 볼 수 있는데, 아래 이미지를 보자.
  
![Pipeline](/assets/images/GraphicPipeline/rendering-pipeline-010.jpeg)
  
붉은색 상자로 표현된 부분(입력 조립, 래스터라이저, 출력병합)은 **고정 파이프라인**이라고 불리며,

*개발자가 코드로 처리하지 않고 장치(그래픽 카드)에서 처리*해주는 영역이다.

하얀색 상자로 표현된 부분(버텍스 셰이더, 픽셀 셰이더)은 **프로그래머블 파이프라인**이라고 불리며, *개발자가 셰이더 코드로 데이터를 접근해 조작이 가능*한 영역이다.

노란색 부분인 테셀레이션은 일부분은 장치에 처리해주기도 하지만 몇몇 설정은 개발자가 가능한 영역이다.

보통 렌더링 파이프라인이라고 하면 **입력 조립 - 버텍스 셰이더 - 래스터라이저 - 픽셀셰이더 - 출력병합**을 가르킨다.

### 입력 조립 (Input Assembly)

입력 조립은 CPU로 부터 받은 그리기 명령과 VRAM의 데이터를 가지고 기본 도형(Primitive)으로 조립하는 과정이다.

![RAM to VRAM](/assets/images/GraphicPipeline/rendering-pipeline-007.jpeg)
  
RAM에 저장되어 있는 데이터는 VRAM으로 복사되어 보내지는데, 해당 데이터는 GPU가 처리하기 쉬운 형태로 직렬화되어 저장되어 있다.

이 정보들은 미리 개발자가 정의해둔 형태(정점 구조체 선언)로 가공되고 이 가공된 정점 데이터 정보를 가지고 기본 삼각형으로 조립하여 다음 단계로 넘겨준다.

> 정점 구조체(Vertex Structure)는 각 정점이 어떤 데이터를 포함 할것인지를 정의 한다.
    예를 들어 `position`, `normal`, `uv`같은 속성들이 포함되며, GPU는 이것을 기반으로 삼각형(Primitive)를 구성한다.

### 버텍스 셰이더 (Vertex Shader)

버텍스 혹은 정점 셰이더는 입력 조립에서 넘어온 도형 데이터를 가지고 공간 변환(MVP)을 하는 단계이다.

M, V, P 는 각 변환에 사용되는 변환 행렬의 이름이기도 한다.

![coordinate transform](https://learnopengl.com/img/getting-started/coordinate_systems.png)

1. 모델 변환(M)
    - 모델(로컬) 공간 => 월드 공간
    - 오브젝트는 고유공간(자신의 피벗 위치를 0, 0, 0을 기준)을 가지는데 이 공간을 월드에 어느 위치에 배치 시킬것인지를 정의 한다.
    - 이 과정에서 이동(Translate), 회전(Rotation), 크기(Scale)도 변환한다.
    - 이동, 회전, 크기 변환은 각각 이루어 질 수도 있지만 각 행렬 합처서 한번에 처리도 가능한데 이 행렬을 TRS(Translation-Rotation-Scale) 행렬이라고 한다.

2. 뷰 변환(V)
    - 월드 공간 => 카메라 공간
    - 카메라의 위치를 기준으로 카메라가 바라보는 방향을 z+로 이루는 공간

3. 투영 변환(P)
    - 카메라 공간 => 클립 공간
    - 화면에 보여지는 공간인 절두체(Frustum)이 정의한다.
    - 절두체는 4면으로 이루어져 있으며 카메라와 가까운 면을 near, 먼 곳의 면을 far 라고 하며 시야각인 fov(field of view)가 정의 된다.
    - 절두체 영역 포함(경계면도 포함)되는 오브젝트들은 유지되고, 절두체 바깥에 있는 오브젝트는 컬링된다.
    - 원근감이 있는 투영은 원근투영(perspective projection), 원근감이 없는 투영은 직교투영(orthographic projection)이라 한다.
    - 클립 공간의 좌표계는 x, y, z, w 값을 가지는 동차 좌표계라 하며 모든 x, y 좌표는 -1 ~ 1 사이의 값을 가지며 z는 1 ~ 0 좌표를 가진다.

### 래스터라이저 (Rasterizer)

하드웨어 자체 알고리즘으로 동작하는 고정 파이프라인 단계이다.

클립 공간의 정점 정보를 넘겨받아 화면에 출력할 프래그먼트(Fragment) 정보를 구성한다.

그리고 다양한 화면에 대응하기 위해 동차 좌표계를 NDC라는 좌표로 변환한다.

래스터라이저는 5가지 기능을 처리한다.

1. 클리핑
    - 투영 변환에서 절두체 바깥의 오브젝트들은 컬링이 되었지만 절두체 경계에 있는 오브젝트는 아직 컬링되지 않았다.
    - 절두체 경계에 내부에 있는 부분과 외부에 있는 부분을 분리시켜 외부 부분을 컬링한다
  
2. 원근 분할
    - 클립 공간의 동차 좌표계는 x, y, z, w로 구성되는데 각 x, y, z에 w를 나눠서 원근을 표현하는데 이를 원근 분할이라 한다.
    - 원근 분할이 종료된 좌표계를 NDC(Normalized Device Coordinates)라고 한다.

3. 후면 컬링(back face culling)
    - 폴리곤의 노멀 벡터와 view 벡터로 오브젝트의 후면을 찾아내어 앞면에 의해 가려지는 부분을 컬링한다.

4. 뷰포트 변환
    - NDC로 변환된 좌표를 스크린 좌표계(2D)로 변환한다.
    - 2D 좌표계로 변환되어도 z 값은 남겨두는데 이를 이용하여 깊이(어떤 오브젝트가 앞에 있는지)를 판별한다.

5. 스캔 변환
    - 프리미티브 도형를 픽셀 위치에 대응시켜 프래그먼트 정보를 구성하고 프래그먼트를 채우는 픽셀들을 찾아낸다.()
    - 정점 정보(위치, 색상, UV)를 이용하여 색상 정보를 할당한다.

### 픽셀 셰이더 (Pixel / Fragment Shader)

픽셀 혹은 프래그먼트 셰이더는 화면에 보여지는 픽셀의 색상을 결정짓는 단계이다.

화면에 그려질 픽셀의 수 만큼 셰이더가 실행된다.

GPU는 수천 개의 셰이더 코어에서 이 연산을 *병렬로 처리하므로*, 프레임 단위의 대규모 픽셀 연산도 실시간으로 수행이 가능하다.

### 출력 병합 (Output Merge)

화면에 출력되기전 마지막 단계로 아래와 같은 연산을 처리한다.

각 단계에서 넘어온 데이터는 버퍼에 기록되어 넘어오는데 일종의 텍스쳐 형태로 구성된다.

- z-buffer 값을 이용하여 물체가 앞에 있는지 뒤에있는지를 판별하는 z-test 혹은 depth-test
- stencil buffer값을 이용하여 화면 특정 위치를 마스크 하는 stencil test
- 색상의 알파값을 가지고 색상을 자연스럽게 합치는 Alpha Blending

픽셀 셰이더의 결과를 Z-버퍼, 스텐실 버퍼, 컬러 버퍼와 비교 결합하여 최종 색상을 결정하고 완성된 이미지를 프레임 버퍼(Frame Buffer)에 저장된다.

이제 비로소 만들어진 프레임이 화면에 출력된다.

## 전체 파이프라인 요약

```txt
[CPU Command] -> [Input Assembly] -> [Vertex Shader] -> [Rasterizer] 
-> [Pixel / Fragment Shader] -> [Output Merge] -> [Frame Buffer]
```

## 출처 및 같이 보기

- [OpenGL Coordinate system](https://learnopengl.com/Getting-started/Coordinate-Systems)
- [rito15 님의 파이프라인 간단 정리](https://rito15.github.io/posts/rendering-pipeline/)